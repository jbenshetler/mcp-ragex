#!/usr/bin/env python3
"""
RAGex - Smart code search with project isolation and MCP support

This Python implementation replaces the bash ragex script with:
- Robust argument parsing using argparse
- Integrated MCP server support with --mcp flag
- Better error handling and debugging
"""

import argparse
import asyncio
import hashlib
import json
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Tuple, Dict, Any

__version__ = "2.0.0"  # Python implementation version


class RagexCLI:
    """Main RAGex CLI implementation"""
    
    def __init__(self):
        # Load configuration first
        config = self.load_config()
        
        # Priority: CLI env var > saved config > default
        self.docker_image = (
            os.environ.get('RAGEX_DOCKER_IMAGE')  # CLI override
            or config.get('docker_image')         # Saved config
            or 'ghcr.io/jbenshetler/mcp-ragex:cpu-latest'  # Default to CPU
        )
        
        self.user_id = os.getuid()
        self.group_id = os.getgid()
        self.debug = os.environ.get('RAGEX_DEBUG', '').lower() in ('true', '1', 'yes')
        self.embedding_model = os.environ.get('RAGEX_EMBEDDING_MODEL', 'fast')
        self.config_mode = config.get('mode', 'cpu')
        
        # GPU detection
        self._gpu_available = None
        self._is_cuda_image = None
        
        # Workspace path - will be set based on command
        self.workspace_path = Path.cwd()
        
        # Project identifiers - computed after workspace is determined
        self._project_id = None
        self._project_name = None
        self._daemon_container_name = None
        self._user_volume = None
    
    @property
    def project_id(self) -> str:
        """Get or compute project ID"""
        if self._project_id is None:
            self._project_id = self.generate_project_id(self.workspace_path)
        return self._project_id
    
    @property
    def project_name(self) -> str:
        """Get project name (basename of workspace)"""
        if self._project_name is None:
            self._project_name = self.workspace_path.name
        return self._project_name
    
    @property
    def daemon_container_name(self) -> str:
        """Get daemon container name"""
        if self._daemon_container_name is None:
            self._daemon_container_name = f"ragex_daemon_{self.project_id}"
        return self._daemon_container_name
    
    @property
    def user_volume(self) -> str:
        """Get user volume name"""
        if self._user_volume is None:
            self._user_volume = f"ragex_user_{self.user_id}"
        return self._user_volume
    
    def get_config_dir(self) -> Path:
        """Get XDG-compliant config directory"""
        config_home = os.environ.get('XDG_CONFIG_HOME', str(Path.home() / '.config'))
        return Path(config_home) / 'ragex'
    
    def load_config(self) -> dict:
        """Load configuration file"""
        config_file = self.get_config_dir() / 'config.json'
        if config_file.exists():
            try:
                with open(config_file) as f:
                    return json.load(f)
            except (json.JSONDecodeError, IOError) as e:
                print(f"âš ï¸  Warning: Could not load config file {config_file}: {e}", file=sys.stderr)
        return {}
    
    def save_config(self, config: dict) -> None:
        """Save configuration file"""
        config_file = self.get_config_dir() / 'config.json'
        config_file.parent.mkdir(parents=True, exist_ok=True)
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
    
    def debug_print(self, message: str):
        """Print debug message if debug mode is enabled"""
        if self.debug:
            print(f"[DEBUG] {message}", file=sys.stderr)
    
    def is_cuda_image(self) -> bool:
        """Check if current Docker image is a CUDA image"""
        if self._is_cuda_image is None:
            # Check if image name contains cuda or has cuda tag
            image_lower = self.docker_image.lower()
            self._is_cuda_image = 'cuda' in image_lower or image_lower.endswith(':cuda-dev')
            self.debug_print(f"Image {self.docker_image} is CUDA: {self._is_cuda_image}")
        return self._is_cuda_image
    
    def is_gpu_available(self) -> bool:
        """Check if GPU is available on the host system"""
        if self._gpu_available is None:
            try:
                # Check if nvidia-smi exists and works
                result = subprocess.run(
                    ['nvidia-smi', '--query-gpu=name', '--format=csv,noheader'],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                self._gpu_available = result.returncode == 0 and bool(result.stdout.strip())
                if self._gpu_available:
                    gpu_names = result.stdout.strip().split('\n')
                    self.debug_print(f"Found {len(gpu_names)} GPU(s): {gpu_names}")
                else:
                    self.debug_print("nvidia-smi failed or returned no GPUs")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self._gpu_available = False
                self.debug_print("nvidia-smi not found or timed out")
        
        return self._gpu_available
    
    def should_use_gpu(self) -> bool:
        """Determine if GPU should be used for container"""
        use_gpu = self.is_cuda_image() and self.is_gpu_available()
        self.debug_print(f"Should use GPU: {use_gpu} (CUDA image: {self.is_cuda_image()}, GPU available: {self.is_gpu_available()})")
        return use_gpu
    
    def generate_project_id(self, workspace_path: Path) -> str:
        """Generate consistent project ID based on user and absolute path"""
        abs_path = workspace_path.resolve()
        project_hash = hashlib.sha256(
            f"{self.user_id}:{abs_path}".encode()
        ).hexdigest()[:16]
        return f"ragex_{self.user_id}_{project_hash}"
    
    def is_daemon_running(self) -> bool:
        """Check if daemon container is running"""
        result = subprocess.run(
            ['docker', 'ps', '-q', '-f', f'name={self.daemon_container_name}'],
            capture_output=True,
            text=True
        )
        return bool(result.stdout.strip())
    
    def start_daemon(self, silent: bool = False) -> bool:
        """Start daemon container if not already running"""
        if self.is_daemon_running():
            self.debug_print(f"Daemon already running: {self.daemon_container_name}")
            return True
        
        if not silent:
            print(f"ðŸš€ Starting ragex daemon for {self.project_name}...")
        
        # Docker run command for daemon
        docker_cmd = [
            'docker', 'run', '-d',
            '--name', self.daemon_container_name,
            '-u', f'{self.user_id}:{self.group_id}',
            '-v', f'{self.user_volume}:/data',
            '-v', f'{self.workspace_path}:/workspace:ro',
            '-e', f'WORKSPACE_PATH={self.workspace_path}',
            '-e', f'PROJECT_NAME={self.project_id}',
            '-e', f'RAGEX_EMBEDDING_MODEL={self.embedding_model}',
            '-e', f'HOST_HOME={Path.home()}',
            '-e', f'RAGEX_LOG_LEVEL={os.environ.get("RAGEX_LOG_LEVEL", "INFO")}'
        ]
        
        # Add GPU support if available and using CUDA image
        if self.should_use_gpu():
            docker_cmd.extend(['--gpus', 'all'])
            if not silent:
                print("ðŸš€ GPU acceleration enabled")
        elif self.is_cuda_image() and not self.is_gpu_available():
            if not silent:
                print("âš ï¸  CUDA image detected but no GPU available - running in CPU mode")
        
        docker_cmd.extend([self.docker_image, 'daemon'])
        
        self.debug_print(f"Starting daemon: {' '.join(docker_cmd)}")
        
        result = subprocess.run(docker_cmd, capture_output=True, text=True)
        if result.returncode != 0:
            if not silent:
                print(f"âŒ Failed to start daemon: {result.stderr}")
            return False
        
        # Wait for daemon to be ready (check for socket)
        if not silent:
            print("â³ Waiting for daemon to be ready...")
        for i in range(10):
            time.sleep(1)
            check_result = subprocess.run(
                ['docker', 'exec', self.daemon_container_name, 
                 'test', '-S', '/tmp/ragex.sock'],
                capture_output=True
            )
            if check_result.returncode == 0:
                if not silent:
                    print("âœ… Socket daemon is ready")
                return True
        
        # If we get here, daemon failed to start properly
        if not silent:
            print("âŒ Daemon container is running but socket not found")
            self.show_daemon_logs(tail=20)
        self.stop_daemon()
        return False
    
    def stop_daemon(self) -> bool:
        """Stop daemon container"""
        if not self.is_daemon_running():
            print(f"â„¹ï¸  No daemon running for {self.project_name}")
            return True
        
        print("ðŸ›‘ Stopping ragex daemon...")
        subprocess.run(['docker', 'stop', self.daemon_container_name], 
                      capture_output=True)
        subprocess.run(['docker', 'rm', self.daemon_container_name], 
                      capture_output=True)
        print("âœ… Daemon stopped")
        return True
    
    def show_daemon_logs(self, tail: Optional[int] = None):
        """Show daemon container logs"""
        cmd = ['docker', 'logs', self.daemon_container_name]
        if tail:
            cmd.extend(['--tail', str(tail)])
        subprocess.run(cmd)
    
    def exec_via_daemon(self, cmd: str, args: List[str], 
                       use_tty: bool = True) -> int:
        """Execute command via daemon using socket client"""
        # Start daemon if not running
        if not self.is_daemon_running():
            if not self.start_daemon():
                return 1
        
        # Determine docker exec flags
        exec_flags = ['-i']
        if use_tty and sys.stdin.isatty() and cmd not in ['serve', 'search']:
            exec_flags.append('-t')
        
        # Add environment variables for commands that need them
        env_vars = []
        if cmd in ['index', 'start']:
            env_vars.extend([
                '-e', f'WORKSPACE_PATH={self.workspace_path}',
                '-e', f'DOCKER_USER_ID={os.getuid()}'
            ])
        
        # Build docker exec command
        docker_cmd = ['docker', 'exec'] + exec_flags + env_vars + [
            self.daemon_container_name,
            'python', '-m', 'src.socket_client', cmd
        ] + args
        
        self.debug_print(f"Executing: {' '.join(docker_cmd)}")
        
        result = subprocess.run(docker_cmd)
        return result.returncode
    
    def parse_args(self) -> argparse.Namespace:
        """Parse command line arguments"""
        parser = argparse.ArgumentParser(
            description='RAGex - Smart code search with project isolation',
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog=self.get_usage_examples()
        )
        
        # Check for --mcp flag before creating subparsers
        if '--mcp' in sys.argv:
            # Minimal parsing for MCP mode
            parser.add_argument('--mcp', action='store_true', 
                              help='Run as MCP server')
            return parser.parse_args(['--mcp'])
        
        subparsers = parser.add_subparsers(dest='command', help='Commands')
        
        # Index command
        index_parser = subparsers.add_parser('index', 
            help='Build semantic index and start daemon')
        index_parser.add_argument('path', nargs='?', default='.', 
            help='Path to index (default: current directory)')
        index_parser.add_argument('--force', action='store_true',
            help='Force rebuild of index')
        index_parser.add_argument('-v', '--verbose', action='store_true',
            help='Show verbose output including debug logs')
        index_parser.add_argument('--name',
            help='Custom name for the project (must be unique, cannot be changed later)')
        
        # Search command
        search_parser = subparsers.add_parser('search', 
            help='Search in current project')
        search_parser.add_argument('query', help='Search query')
        search_parser.add_argument('--limit', type=int, default=50,
            help='Maximum results (default: 50)')
        search_parser.add_argument('--symbol', action='store_true',
            help='Symbol search mode')
        search_parser.add_argument('--regex', action='store_true',
            help='Regex search mode')
        search_parser.add_argument('--json', action='store_true',
            help='Output results as JSON')
        
        # Help command
        help_parser = subparsers.add_parser('help',
            help='Show help message')
        
        # Stop command
        stop_parser = subparsers.add_parser('stop',
            help='Stop daemon if running')
        
        # Status command
        status_parser = subparsers.add_parser('status',
            help='Check daemon status')
        
        # Start command (alias for index .)
        start_parser = subparsers.add_parser('start',
            help='Index current directory (alias for \'index .\')')
        start_parser.add_argument('--name',
            help='Custom name for the project (must be unique, cannot be changed later)')
        
        # List projects command
        ls_parser = subparsers.add_parser('ls',
            help='List projects (optional glob filter, -l for details)',
            add_help=False)  # Disable default help to use -h for human-readable
        ls_parser.add_argument('glob', nargs='?',
            help='Project ID or glob to filter projects')
        ls_parser.add_argument('-l', '--long', action='store_true',
            help='Show detailed information including model and index status')
        ls_parser.add_argument('-a', '--all', action='store_true',
            help='Show all projects including admin projects')
        ls_parser.add_argument('-h', '--human-readable', action='store_true',
            help='Show sizes in human-readable format (e.g., 1K, 234M, 2G)')
        ls_parser.add_argument('--help', action='help',
            help='Show this help message and exit')
        
        # Remove project command
        rm_parser = subparsers.add_parser('rm',
            help='Remove project(s) by ID or glob')
        rm_parser.add_argument('glob', help='Project ID or glob to remove')
        
        # Configure command
        configure_parser = subparsers.add_parser('configure',
            help='Configure image mode')
        configure_parser.add_argument('--cpu', action='store_true',
            help='Use CPU mode')
        configure_parser.add_argument('--cuda', action='store_true',
            help='Use CUDA mode')
        configure_parser.add_argument('--rocm', action='store_true',
            help='Use ROCm mode (future)')
        configure_parser.add_argument('--image',
            help='Use custom image')
        
        # Info command
        info_parser = subparsers.add_parser('info',
            help='Show project information')
        
        # Log command
        log_parser = subparsers.add_parser('log',
            help='Show/follow daemon logs')
        log_parser.add_argument('project', nargs='?',
            help='Project name/ID (omit for global logs)')
        log_parser.add_argument('-f', '--follow', action='store_true',
            help='Follow log output')
        log_parser.add_argument('--tail', type=int, metavar='N',
            help='Number of lines to show from the end')
        log_parser.add_argument('-t', '--timestamps', action='store_true',
            help='Show timestamps')
        
        # Register/unregister commands
        register_parser = subparsers.add_parser('register',
            help='Show registration command (use --help for details)')
        register_parser.add_argument('target', 
            help='Registration target (e.g., claude)')
        register_parser.add_argument('--help-register', action='store_true',
            help='Show detailed help for register command', dest='help_flag')
        register_parser.add_argument('--global', action='store_true',
            help='Register globally instead of project-scoped')
        
        unregister_parser = subparsers.add_parser('unregister',
            help='Show unregistration command (use --help for details)')
        unregister_parser.add_argument('target',
            help='Unregistration target (e.g., claude)')
        unregister_parser.add_argument('--help-unregister', action='store_true',
            help='Show detailed help for unregister command', dest='help_flag')
        unregister_parser.add_argument('--global', action='store_true',
            help='Unregister globally instead of project-scoped')
        
        return parser.parse_args()
    
    def get_usage_examples(self) -> str:
        """Get usage examples for help text"""
        return """
Quick Start:
  1. ragex start                # Index current directory
  2. ragex search "query"       # Search your codebase (semantic)

Examples:
  ragex start                      # Quick start in current directory
  ragex index /path/to/project     # Index specific directory
  
  # Search modes:
  ragex search "auth functions"    # Semantic search (default)
  ragex search "user login flow"   # Finds conceptually related code
  ragex search "def.*test" --regex # Regex pattern matching
  ragex search "handleSubmit" --symbol # Exact symbol/function name
  
  # Project management:
  ragex ls                         # Show all your projects
  ragex ls -l                      # Show projects with model and index status
  ragex ls "my-*"                  # List projects matching glob
  ragex rm "old-*"                 # Remove projects matching glob
  
  # Other commands:
  ragex log mcp-ragex -f           # Follow logs for specific project
  ragex register claude | sh       # Register with Claude
  ragex --mcp                      # Run as MCP server

Note: Running 'ragex start' or 'ragex index' from anywhere inside an already
indexed project will reuse the existing project (based on the project root path).

Environment Variables:
  RAGEX_EMBEDDING_MODEL    Embedding model preset (fast/balanced/accurate)
  RAGEX_PROJECT_NAME       Override project name
  RAGEX_DOCKER_IMAGE       Docker image to use
  RAGEX_DEBUG              Enable debug output
"""
    
    def run(self) -> int:
        """Main entry point"""
        # Special handling for --mcp mode
        if '--mcp' in sys.argv:
            return self.run_mcp_mode()
        
        # Parse arguments
        args = self.parse_args()
        
        # Show help if no command
        if not args.command:
            subprocess.run([sys.argv[0], '--help'])
            return 0
        
        # Update workspace path for index command
        if args.command == 'index' and hasattr(args, 'path'):
            self.workspace_path = Path(args.path).resolve()
        
        # Route to command handlers
        handler_name = f'cmd_{args.command.replace("-", "_")}'
        handler = getattr(self, handler_name, None)
        
        if handler:
            return handler(args)
        else:
            print(f"âŒ Error: Unknown command '{args.command}'")
            print(f"\nRun '{sys.argv[0]} --help' for usage")
            return 1
    
    # Command handlers
    def cmd_index(self, args: argparse.Namespace) -> int:
        """Handle index command"""
        print(f"ðŸ“š Indexing {self.workspace_path}")
        # Inside container, the workspace is always mounted at /workspace
        container_path = '/workspace'
        cmd_args = [container_path]
        if args.force:
            cmd_args.append('--force')
        if hasattr(args, 'verbose') and args.verbose:
            cmd_args.append('--verbose')
        if hasattr(args, 'name') and args.name:
            cmd_args.extend(['--name', args.name])
        return self.exec_via_daemon('index', cmd_args)
    
    def cmd_search(self, args: argparse.Namespace) -> int:
        """Handle search command"""
        cmd_args = [args.query]
        
        if args.limit != 50:
            cmd_args.extend(['--limit', str(args.limit)])
        if args.symbol:
            cmd_args.append('--symbol')
        if args.regex:
            cmd_args.append('--regex')
        if args.json:
            cmd_args.append('--json')
        
        return self.exec_via_daemon('search', cmd_args, use_tty=not args.json)
    
    def cmd_help(self, args: argparse.Namespace) -> int:
        """Handle help command - show help and exit"""
        subprocess.run([sys.argv[0], '--help'])
        return 0
    
    def cmd_stop(self, args: argparse.Namespace) -> int:
        """Handle stop command"""
        return 0 if self.stop_daemon() else 1
    
    def cmd_status(self, args: argparse.Namespace) -> int:
        """Handle status command"""
        if self.is_daemon_running():
            print(f"âœ… Daemon is running for {self.project_name}")
            result = subprocess.run(
                ['docker', 'ps', '-f', f'name={self.daemon_container_name}',
                 '--format', 'table {{.ID}}\t{{.Status}}\t{{.Names}}']
            )
            return 0
        else:
            print(f"âŒ No daemon running for {self.project_name}")
            return 1
    
    def cmd_info(self, args: argparse.Namespace) -> int:
        """Handle info command"""
        print("ðŸ”§ RageX Project Information")
        print(f"   User ID: {self.user_id}")
        print(f"   Workspace: {self.workspace_path}")
        print(f"   Project ID: {self.project_id}")
        print(f"   Project Name: {self.project_name}")
        print(f"   User Volume: {self.user_volume}")
        print(f"   Docker Image: {self.docker_image}")
        print(f"   Embedding Model: {self.embedding_model}")
        print()
        return self.cmd_status(args)
    
    def cmd_start(self, args: argparse.Namespace) -> int:
        """Handle start command (alias for index .)"""
        # Update workspace to current directory
        self.workspace_path = Path('.').resolve()
        # Create a fake args object for index command
        index_args = argparse.Namespace(command='index', path='.', force=False)
        # Pass through the --name flag if provided
        if hasattr(args, 'name') and args.name:
            index_args.name = args.name
        return self.cmd_index(index_args)
    
    def cmd_ls(self, args: argparse.Namespace) -> int:
        """Handle ls command"""
        cmd_args = []
        if hasattr(args, 'long') and args.long:
            cmd_args.append('-l')
        if hasattr(args, 'all') and args.all:
            cmd_args.append('-a')
        if hasattr(args, 'human_readable') and args.human_readable:
            cmd_args.append('-h')
        if hasattr(args, 'glob') and args.glob:
            cmd_args.append(args.glob)
        return self._run_admin_command('ls', cmd_args)
    
    def cmd_rm(self, args: argparse.Namespace) -> int:
        """Handle rm command"""
        return self._run_admin_command('rm', [args.glob])
    
    def cmd_register(self, args: argparse.Namespace) -> int:
        """Handle register command"""
        cmd_args = [args.target]
        if hasattr(args, 'help_flag') and args.help_flag:
            cmd_args.append('--help')
        if hasattr(args, 'global') and getattr(args, 'global'):
            cmd_args.append('--global')
        return self._run_admin_command('register', cmd_args)
    
    def cmd_unregister(self, args: argparse.Namespace) -> int:
        """Handle unregister command"""
        cmd_args = [args.target]
        if hasattr(args, 'help_flag') and args.help_flag:
            cmd_args.append('--help')
        if hasattr(args, 'global') and getattr(args, 'global'):
            cmd_args.append('--global')
        return self._run_admin_command('unregister', cmd_args)
    
    def cmd_configure(self, args: argparse.Namespace) -> int:
        """Handle configure command"""
        config = self.load_config()
        
        if args.cpu:
            config['docker_image'] = 'ghcr.io/jbenshetler/mcp-ragex:cpu-latest'
            config['mode'] = 'cpu'
            config['configured_at'] = datetime.now().isoformat()
            self.save_config(config)
            print("âœ… Configured for CPU mode")
        elif args.cuda:
            config['docker_image'] = 'ghcr.io/jbenshetler/mcp-ragex:cuda-latest'
            config['mode'] = 'cuda'
            config['configured_at'] = datetime.now().isoformat()
            self.save_config(config)
            print("âœ… Configured for CUDA mode")
        elif args.rocm:
            config['docker_image'] = 'ghcr.io/jbenshetler/mcp-ragex:rocm-latest'
            config['mode'] = 'rocm'
            config['configured_at'] = datetime.now().isoformat()
            self.save_config(config)
            print("âœ… Configured for ROCm mode")
        elif args.image:
            config['docker_image'] = args.image
            config['mode'] = 'custom'
            config['configured_at'] = datetime.now().isoformat()
            self.save_config(config)
            print(f"âœ… Configured for custom image: {args.image}")
        else:
            # Show current configuration
            current_image = (
                os.environ.get('RAGEX_DOCKER_IMAGE')  # CLI override
                or config.get('docker_image')         # Saved config
                or 'ghcr.io/jbenshetler/mcp-ragex:cpu-latest'  # Default
            )
            override_active = bool(os.environ.get('RAGEX_DOCKER_IMAGE'))
            
            print("Current configuration:")
            print(f"  Mode: {config.get('mode', 'cpu')}")
            print(f"  Image: {current_image}")
            if override_active:
                print(f"  Override: RAGEX_DOCKER_IMAGE environment variable is active")
            if config.get('configured_at'):
                print(f"  Last configured: {config.get('configured_at')}")
            if config.get('installed_at'):
                print(f"  Installed: {config.get('installed_at')}")
            
            config_file = self.get_config_dir() / 'config.json'
            print(f"  Config file: {config_file}")
        
        return 0
    
    def cmd_log(self, args: argparse.Namespace) -> int:
        """Handle log command"""
        if args.project:
            # Project-specific logs
            return self._show_project_logs(args.project, args)
        else:
            # If no project specified, try to show logs for current project
            if self.is_daemon_running():
                # Show logs for current project's daemon
                return self._show_current_project_logs(args)
            else:
                # No daemon running for current project, show global logs
                return self._show_global_logs(args)
    
    def _run_admin_command(self, command: str, args: List[str] = None) -> int:
        """Run administrative commands that don't need workspace"""
        docker_cmd = [
            'docker', 'run', '--rm',
            '-u', f'{self.user_id}:{self.group_id}',
            '-v', f'{self.user_volume}:/data',
            '-e', 'PROJECT_NAME=admin',
            '-e', f'HOST_HOME={Path.home()}',
            '-e', f'HOST_USER={os.environ.get("USER", "unknown")}',
            '-e', f'WORKSPACE_PATH={self.workspace_path}',
            self.docker_image,
            command
        ]
        
        if args:
            docker_cmd.extend(args)
        
        self.debug_print(f"Running admin command: {' '.join(docker_cmd)}")
        result = subprocess.run(docker_cmd)
        return result.returncode
    
    def _show_project_logs(self, project_identifier: str, 
                          args: argparse.Namespace) -> int:
        """Show logs for specific project"""
        # Resolve project name to ID
        resolve_result = subprocess.run(
            ['docker', 'run', '--rm',
             '-v', f'{self.user_volume}:/data',
             '--entrypoint', 'python',
             self.docker_image,
             '-m', 'src.ragex_core.project_resolver', project_identifier],
            capture_output=True,
            text=True
        )
        
        if resolve_result.returncode != 0:
            error_msg = resolve_result.stderr.strip()
            if error_msg.startswith("ERROR: "):
                print(f"âŒ {error_msg[7:]}")
            else:
                print(f"âŒ Failed to resolve project: {project_identifier}")
            return 1
        
        project_id = resolve_result.stdout.strip()
        container_name = f"ragex_daemon_{project_id}"
        
        # Check if container exists
        check_result = subprocess.run(
            ['docker', 'ps', '-q', '-f', f'name={container_name}'],
            capture_output=True,
            text=True
        )
        
        if not check_result.stdout.strip():
            print(f"âŒ No running daemon found for project: {project_identifier}")
            if project_identifier != project_id:
                print(f"   (Resolved to: {project_id})")
            return 1
        
        # Show logs without decoration
        
        log_cmd = ['docker', 'logs', container_name]
        if args.follow:
            log_cmd.append('--follow')
        if args.tail:
            log_cmd.extend(['--tail', str(args.tail)])
        if args.timestamps:
            log_cmd.append('--timestamps')
        
        # Redirect docker logs stderr to stdout so logs can be piped properly
        result = subprocess.run(log_cmd, stderr=subprocess.STDOUT)
        return result.returncode
    
    def _show_current_project_logs(self, args: argparse.Namespace) -> int:
        """Show logs for current project's daemon"""
        log_cmd = ['docker', 'logs', self.daemon_container_name]
        
        if args.follow:
            log_cmd.append('--follow')
        if args.tail:
            log_cmd.extend(['--tail', str(args.tail)])
        if args.timestamps:
            log_cmd.append('--timestamps')
        
        # Redirect docker logs stderr to stdout so logs can be piped properly
        result = subprocess.run(log_cmd, stderr=subprocess.STDOUT)
        return result.returncode
    
    def _show_global_logs(self, args: argparse.Namespace) -> int:
        """Show logs from all daemon containers"""
        # Find all daemon containers
        result = subprocess.run(
            ['docker', 'ps', '--format', '{{.Names}}'],
            capture_output=True,
            text=True
        )
        
        daemon_containers = [
            name for name in result.stdout.strip().split('\n')
            if name.startswith('ragex_daemon_')
        ]
        
        if not daemon_containers:
            return 0
        
        for container in sorted(daemon_containers):
            log_cmd = ['docker', 'logs', container]
            if args.tail:
                log_cmd.extend(['--tail', str(args.tail)])
            if args.timestamps:
                log_cmd.append('--timestamps')
            
            # Redirect docker logs stderr to stdout so logs can be piped properly
            result = subprocess.run(log_cmd, stderr=subprocess.STDOUT)
        
        return 0
    
    def run_mcp_mode(self) -> int:
        """Run as MCP server bridging to daemon"""
        # In MCP mode, we must be completely silent - no output except JSON protocol
        
        # Ensure daemon is running (silent mode)
        if not self.is_daemon_running():
            if not self.start_daemon(silent=True):
                # If we can't start daemon, we need to exit silently
                # MCP server will handle error reporting via JSON
                return 1
        
        # Start continuous indexing to ensure ChromaDB exists
        # TODO: This blocks MCP server - need to run as background task
        # For now, commented out - user must run 'ragex index' first
        # container_path = '/workspace'
        # docker_cmd = ['docker', 'exec', '-i', self.daemon_container_name,
        #               'python', '-m', 'src.socket_client', 'start_continuous_index', container_path]
        # subprocess.run(docker_cmd, capture_output=True)  # Discard all output
        
        # Run MCP server inside the container where dependencies are available
        # This takes over stdio for clean JSON communication
        docker_cmd = ['docker', 'exec', '-i',  # -i for interactive, no -t for MCP stdio
                      self.daemon_container_name,
                      'python', '-m', 'src.socket_client', 'mcp']
        
        # Run the MCP server command - it will handle all stdio from here
        # Pass through stdin/stdout/stderr for proper MCP communication
        result = subprocess.run(docker_cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr)
        return result.returncode


def main():
    """Main entry point"""
    cli = RagexCLI()
    sys.exit(cli.run())


if __name__ == '__main__':
    main()